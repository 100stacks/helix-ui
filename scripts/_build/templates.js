const CleanCSS = require('clean-css');
const HTMLMinify = require('html-minifier').minify;
const globby = require('globby');
const less = require('less');
const path = require('path');

const { readFile, writeFile } = require('../_util');
const elementsDir = path.resolve(__dirname, '../../src/elements');

/**
 * @async
 * @param {string} htmlContent
 * @returns {Promise<string>} Resolves with minified HTML
 */
async function _readHTML (rawHtml) {
    return HTMLMinify(rawHtml, {
        collapseWhitespace: true,
        quoteCharacter: "'", // reduces escape characters
        removeComments: true,
        removeEmptyAttributes: true,
        removeRedundantAttributes: true,
    });
}

/**
 * @async
 * @param {string} filePath - file path to the LESS file
 * @param {string} rawLess - LESS source code
 * @returns {Promise<string>} Resolves to a minified CSS string
 */
async function _parseLESS (filePath, rawLess) {
    let filename = path.isAbsolute(filePath)
        ? filePath
        : path.join(elementsDir, filePath);

    let opts = {
        filename, // MUST BE ABSOLUTE!
        paths: [
            path.resolve(__dirname, '../../src/styles')
        ],
    };

    let rendered = await less.render(rawLess, opts);
    let minified = new CleanCSS().minify(rendered.css);

    return minified.styles;
}

/**
 * Divides up work to parse different file types.
 * @async
 * @param {string} filename
 * @returns {Promise<object>} Resolves to file metadata object containing partial ShadowDOM content
 */
async function _parseFile (filename) {
    let absFilePath = path.join(elementsDir, filename);
    let ext = path.extname(filename);
    let basename = path.basename(filename, ext);

    let meta = { basename };
    let fileContent = await readFile(absFilePath, { encoding: 'utf8' });
    switch (ext) {
        case '.html':
            meta.markup = await _readHTML(fileContent);
            break;

        case '.less':
            meta.styles = await _parseLESS(absFilePath, fileContent);
            break;

        default:
            throw new Error(`Unsupported file type: ${filename}`);
            break;
    }

    return meta;
}

/**
 * Combines partial metadata objects into a single template object value for each unique basename.
 * @private
 * @param {object} templates - accumulator
 * @param {object} datum - resolved file metadata object from _parseFile()
 * @returns {object} accumulator
 */
function _aggregateMetadata (templates, datum) {
    let { basename, markup, styles } = datum;
    let _template = templates[basename] || {};

    if (markup) {
        _template.markup = markup;
    }

    if (styles) {
        _template.styles = styles;
    }

    templates[basename] = _template;

    return templates;
}

/**
 * Iterates over ShadowDOM content to generate HTML and CSS template strings
 * for consumption within custom element classes.
 * @async
 */
async function buildTemplates () {
    // ['HXAccordionPanelElement.html', 'HXAccordionPanelElement.less', ...]
    let files = await globby([
        '*.(html|less)',
        '!HXElement.less',
        '!_*'
    ], { cwd: elementsDir });

    // [Promise<object>, ...]
    let parsedFiles = files.map(_parseFile);

    // [{ filename, styles|markup }, ...]
    let metadata = await Promise.all(parsedFiles);

    // { HXAccordionPanelElement: { styles: '', markup: '' }, ... }
    const TEMPLATES = metadata.reduce(_aggregateMetadata, {
        README: 'DO NOT MANUALLY EDIT. This file is automatically generated.'
    });

    let tmplPath = path.join(elementsDir, 'templates.json');
    let tmplData = JSON.stringify(TEMPLATES, null, 2);
    await writeFile(tmplPath, tmplData);
}

exports.buildTemplates = buildTemplates;
