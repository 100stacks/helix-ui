{"version":3,"file":"helix-ui.browser.min.js","sources":["../src/helix-ui/util/position/offsetFunctions.js","../src/helix-ui/util/position.js","../src/helix-ui/index.js","../src/helix-ui/util/keys.js","../src/helix-ui/elements/HXElement.js","../src/helix-ui/elements/HXCheckboxElement.js","../src/helix-ui/elements/HXDisclosureElement.js","../src/helix-ui/elements/HXMenuElement.js","../src/helix-ui/elements/HXIconElement.js","../node_modules/lodash/isObject.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/_root.js","../node_modules/lodash/now.js","../node_modules/lodash/_Symbol.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/isObjectLike.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/debounce.js","../src/helix-ui/elements/HXPopoverElement.js","../src/helix-ui/elements/HXRevealElement.js","../src/helix-ui/elements/HXTabcontentElement.js","../src/helix-ui/elements/HXTabElement.js","../src/helix-ui/elements/HXTablistElement.js","../src/helix-ui/elements/HXTabpanelElement.js","../src/helix-ui/elements/HXTabsetElement.js","../src/helix-ui/elements/HXTooltipElement.js","../src/browser-entry.js"],"sourcesContent":["function getCenter (off, ref) {\n    let x = ref.left + (ref.width / 2) - (off.width / 2);\n    let y = ref.top + (ref.height / 2) - (off.height / 2);\n    return [ x, y ];\n}\n\nfunction getTop (off, ref, config) {\n    let [ x, y ] = getCenter(off, ref);\n    y = ref.top - off.height;\n    y -= config.margin;\n    return [ x, y ];\n}\n\nfunction getBottom (off, ref, config) {\n    let [ x, y ] = getCenter(off, ref);\n    y = ref.top + ref.height;\n    y += config.margin;\n    return [ x, y ];\n}\n\nfunction getLeft (off, ref, config) {\n    let [ x, y ] = getCenter(off, ref);\n    x = ref.left - off.width - config.margin;\n    return [ x, y ];\n}\n\nfunction getRight (off, ref, config) {\n    let [ x, y ] = getCenter(off, ref);\n    x = ref.left + ref.width + config.margin;\n    return [ x, y ];\n}\n\nfunction getTopLeft (off, ref, config) {\n    let [ x, y ] = getTop(off, ref, config);\n    x -= (off.width / 2);\n    x += config.offset;\n    return [ x, y ];\n}\n\nfunction getTopStart (off, ref, config) {\n    let [ x, y ] = getTop(off, ref, config);\n    x = ref.left;\n    x += config.offset;\n    return [ x, y ];\n}\n\nfunction getTopEnd (off, ref, config) {\n    let [ x, y ] = getTop(off, ref, config);\n    x = ref.right - off.width;\n    x -= config.offset;\n    return [ x, y ];\n}\n\nfunction getTopRight (off, ref, config) {\n    let [ x, y ] = getTop(off, ref, config);\n    x += (off.width / 2);\n    x -= config.offset;\n    return [ x, y ];\n}\n\nfunction getRightTop (off, ref, config) {\n    let [ x, y ] = getRight(off, ref, config);\n    y -= (off.height / 2);\n    y += config.offset;\n    return [ x, y ];\n}\n\nfunction getRightStart (off, ref, config) {\n    let [ x, y ] = getRight(off, ref, config);\n    y = ref.top;\n    y += config.offset;\n    return [ x, y ];\n}\n\nfunction getRightEnd (off, ref, config) {\n    let [ x, y ] = getRight(off, ref, config);\n    y = ref.bottom - off.height;\n    y -= config.offset;\n    return [ x, y ];\n}\n\nfunction getRightBottom (off, ref, config) {\n    let [ x, y ] = getRight(off, ref, config);\n    y += off.height / 2;\n    y -= config.offset;\n    return [ x, y ];\n}\n\nfunction getBottomRight (off, ref, config) {\n    let [ x, y ] = getBottom(off, ref, config);\n    x += (off.width / 2);\n    x -= config.offset;\n    return [ x, y ];\n}\n\nfunction getBottomEnd (off, ref, config) {\n    let [ x, y ] = getBottom(off, ref, config);\n    x = ref.right - off.width;\n    x -= config.offset;\n    return [ x, y ];\n}\n\nfunction getBottomStart (off, ref, config) {\n    let [ x, y ] = getBottom(off, ref, config);\n    x = ref.left;\n    x += config.offset;\n    return [ x, y ];\n}\n\nfunction getBottomLeft (off, ref, config) {\n    let [ x, y ] = getBottom(off, ref, config);\n    x -= (off.width / 2);\n    x += config.offset;\n    return [ x, y ];\n}\n\nfunction getLeftBottom (off, ref, config) {\n    let [ x, y ] = getLeft(off, ref, config);\n    y += off.height / 2;\n    y -= config.offset;\n    return [ x, y ];\n}\n\nfunction getLeftEnd (off, ref, config) {\n    let [ x, y ] = getLeft(off, ref, config);\n    y = ref.bottom - off.height;\n    y -= config.offset;\n    return [ x, y ];\n}\n\nfunction getLeftStart (off, ref, config) {\n    let [ x, y ] = getLeft(off, ref, config);\n    y = ref.top;\n    y += config.offset;\n    return [ x, y ];\n}\n\nfunction getLeftTop (off, ref, config) {\n    let [ x, y ] = getLeft(off, ref, config);\n    y -= (off.height / 2);\n    y += config.offset;\n    return [ x, y ];\n}\n\nconst offsetFunctions = {\n    'top-left': getTopLeft,\n    'top-start': getTopStart,\n    'top': getTop,\n    'top-end': getTopEnd,\n    'top-right': getTopRight,\n    'right-top': getRightTop,\n    'right-start': getRightStart,\n    'right': getRight,\n    'right-end': getRightEnd,\n    'right-bottom': getRightBottom,\n    'bottom-right': getBottomRight,\n    'bottom-end': getBottomEnd,\n    'bottom': getBottom,\n    'bottom-start': getBottomStart,\n    'bottom-left': getBottomLeft,\n    'left-bottom': getLeftBottom,\n    'left-end': getLeftEnd,\n    'left': getLeft,\n    'left-start': getLeftStart,\n    'left-top': getLeftTop,\n    'center': getCenter,\n};\n\nexport default offsetFunctions;\n","import offsetFunctions from './position/offsetFunctions';\n\n/**\n * @typedef {Object} Config\n * @param {String} [config.position='top']\n * position of offsetElement in relation to referenceElement\n * @param {Integer} [config.margin=0]\n * distance in pixels between offset element and reference element\n * @param {Integer} [config.offset=0]\n * offset in pixels towards the center axis\n*/\n\n/**\n * Calculate the top, right, bottom, and left x/y values of\n * an element at given coordinates.\n *\n * @function\n * @param {HTMLElement} element\n * @param {Object} coord - (x,y) coordinates\n */\nfunction _getElementBox (element, coord) {\n    let boundingRect = element.getBoundingClientRect();\n\n    return {\n        top: coord.y,\n        right: coord.x + boundingRect.width,\n        bottom: coord.y + boundingRect.height,\n        left: coord.x,\n    };\n}\n\n/**\n * Calculate coordinates of an element in relation to a reference element.\n *\n * @function\n * @param {String} position - the position of the offset element\n * @param {HTMLElement} offsetElement - the element to calculate (x,y) coordinates\n * @param {HTMLElement} referenceElement - the element that is being offset from\n * @param {Config} config - configuration object\n *\n * @returns {Object} absolute (x,y) coordinates and metadata to position offsetElement\n * in relation to referenceElement\n */\nfunction _getCoords (position, offsetElement, referenceElement, config) {\n    // The 'position' property is added to provide information about final\n    // calculated position of offset element in relation to reference element\n    let coords = {\n        x: 0,\n        y: 0,\n        position,\n    };\n\n    let offRect = offsetElement.getBoundingClientRect();\n    let refRect = referenceElement.getBoundingClientRect();\n\n    [ coords.x, coords.y ] = offsetFunctions[position](offRect, refRect, config);\n    coords.x += window.pageXOffset;\n    coords.y += window.pageYOffset;\n\n    return coords;\n}\n\n/**\n * Determine if any side of an element is obscured by the viewport.\n *\n * @function\n * @argument {HTMLElement} element - the element to check against the viewport\n * @argument {Object} coords - (x,y) coordinates\n *\n * @returns {Object} metadata object with boolean values to quickly\n * identify which sides of an element are outside the viewport\n */\nfunction _getOffscreenMetadata (element, coords) {\n    let elementBox = _getElementBox(element, coords);\n    let viewportBox = {\n        top: window.pageYOffset,\n        right: window.innerWidth + window.pageXOffset,\n        bottom: window.innerHeight + window.pageYOffset,\n        left: window.pageXOffset,\n    };\n\n    let offscreen = {\n        top: elementBox.top < viewportBox.top,\n        right: elementBox.right > viewportBox.right,\n        bottom: elementBox.bottom > viewportBox.bottom,\n        left: elementBox.left < viewportBox.left,\n    };\n\n    offscreen.vertically = (offscreen.top || offscreen.bottom);\n    offscreen.horizontally = (offscreen.left || offscreen.right);\n    offscreen.anywhere = (offscreen.vertically || offscreen.horizontally);\n\n    return offscreen;\n}\n\n/**\n * Modify the position of an element so that it appears toward\n * the center of the viewport.\n *\n * @function\n * @param {String} position - the current position\n * @param {Object} offscreen - offscreen metadata\n * @returns {String} corrected position\n */\nfunction _repositionTowardCenter (position, offscreen) {\n    let vShiftMap = {\n        'top': 'bottom',\n        'top-right': 'bottom-right',\n        'top-left': 'bottom-left',\n        'top-start': 'bottom-start',\n        'top-end': 'bottom-end',\n        'right': 'right',\n        'right-top': 'right-bottom',\n        'right-bottom': 'right-top',\n        'right-start': 'right-end',\n        'right-end': 'right-start',\n        'bottom': 'top',\n        'bottom-right': 'top-right',\n        'bottom-left': 'top-left',\n        'bottom-start': 'top-start',\n        'bottom-end': 'top-end',\n        'left': 'left',\n        'left-top': 'left-bottom',\n        'left-bottom': 'left-top',\n        'left-start': 'left-end',\n        'left-end': 'left-start',\n    };\n\n    let hShiftMap = {\n        'top': 'top',\n        'top-right': 'top-left',\n        'top-left': 'top-right',\n        'top-start': 'top-end',\n        'top-end': 'top-start',\n        'right': 'left',\n        'right-top': 'left-top',\n        'right-bottom': 'left-bottom',\n        'right-start': 'left-start',\n        'right-end': 'left-end',\n        'bottom': 'bottom',\n        'bottom-right': 'bottom-left',\n        'bottom-left': 'bottom-right',\n        'bottom-start': 'bottom-end',\n        'bottom-end': 'bottom-start',\n        'left': 'right',\n        'left-top': 'right-top',\n        'left-bottom': 'right-bottom',\n        'left-start': 'right-start',\n        'left-end': 'right-end',\n    };\n\n    if (offscreen.vertically) {\n        position = vShiftMap[position];\n    }\n\n    if (offscreen.horizontally) {\n        position = hShiftMap[position];\n    }\n\n    return position;\n}\n\n/**\n * Calculate coordinates of an element in relation to a reference element\n * while attempting to keep the element visible in the viewport.\n *\n * @function\n * @param {Element} offsetElement element to position\n * @param {Element} referenceElement\n * reference element used to calculate position of offsetElement\n * @param {Config} config - configuration object\n *\n * @returns {Object} (x,y) coordinates\n */\nexport function getPosition (offsetElement, referenceElement, config) {\n    let defaults = {\n        position: 'top',\n        margin: 0,\n        offset: 0,\n    };\n    let cfg = Object.assign({}, defaults, config);\n    \n    let coords = _getCoords(cfg.position, offsetElement, referenceElement, cfg);\n    let isOffscreen = _getOffscreenMetadata(offsetElement, coords);\n\n    if (isOffscreen.anywhere) {\n        let newPosition = _repositionTowardCenter(cfg.position, isOffscreen);\n        let newCoords = _getCoords(newPosition, offsetElement, referenceElement, cfg);\n\n        //If the repositioned element is no longer offscreen,\n        //use the respositioned element coordinates\n        isOffscreen = _getOffscreenMetadata(offsetElement, newCoords);\n        if (!isOffscreen.anywhere) {\n            coords = newCoords;\n        }\n    }\n\n    return coords;\n}\n\n/**\n * Calculate coordinates of an element in relation to a reference element\n * while attempting to keep the element visible in the viewport.\n *\n * @function\n * @param {Element} offsetElement element to position\n * @param {Element} referenceElement\n * reference element used to calculate position of offsetElement\n * @param {Config} config - configuration object\n * @param {Integer} [config.margin=12]\n * distance in pixels between the base and the tip of the arrow\n * @param {Integer} [config.offset=20]\n * distance in pixels from the edge of the offset element to the center of the arrow\n *\n * @returns {Object} (x,y) coordinates\n */\nexport function getPositionWithArrow (offsetElement, referenceElement, config) {\n    let defaults = {\n        margin: 12, // base to tip of the arrow\n        offset: 20, // distance from the edge to the center of the arrow\n    };\n\n    let cfg = Object.assign({}, defaults, config);\n\n    return getPosition(offsetElement, referenceElement, cfg);\n}\n","import { HXElement } from './elements/HXElement';\nimport * as elements from './elements';\n\nfunction _defineElements () {\n    for (let attr in elements) {\n        elements[attr].$define();\n    }\n}\n\nfunction initialize () {\n    if (window.WebComponents) {\n        // Polyfill detected\n        if (window.WebComponents.ready) {\n            // polyfill already finished loading, initialize immediately\n            _defineElements();\n        } else {\n            // initialize when polyfill has finished loading\n            window.addEventListener('WebComponentsReady', function () {\n                _defineElements();\n            });\n        }\n    } else {\n        // No polyfills detected, initialize immediately\n        _defineElements();\n    }\n}\n\nconst DOM = Object.assign({}, elements, { HXElement });\n\nexport default {\n    DOM,\n    initialize,\n}\n","const KEYS = {\n    Alt: 18,\n    Backspace: 8,\n    Control: 17,\n    Delete: 46,\n    Down: 40,\n    End: 35,\n    Enter: 13,\n    Escape: 27,\n    Home: 36,\n    Insert: 45,\n    Left: 37,\n    PageDown: 34,\n    PageUp: 33,\n    Right: 39,\n    Shift: 16,\n    Space: 32,\n    Tab: 9,\n    Up: 38,\n};\n\n// ALIASES\nKEYS['Ctrl'] = KEYS['Control'];\nKEYS['Del'] = KEYS['Delete'];\nKEYS['Esc'] = KEYS['Escape'];\nKEYS['Ins'] = KEYS['Insert'];\nKEYS['Option'] = KEYS['Alt'];\nKEYS['PgDown'] = KEYS['PageDown'];\nKEYS['PgUp'] = KEYS['PageUp'];\nKEYS['Return'] = KEYS['Enter'];\n\nexport default KEYS;\n","import { KEYS } from '../util';\n\nexport class HXElement extends HTMLElement {\n    static $define () {\n        customElements.define(this.is, this);\n    }\n\n    constructor (tagName, template) {\n        super();\n\n        // Don't attach shadow DOM unless specified\n        if (tagName && template) {\n            this.attachShadow({ mode: 'open' });\n\n            if (window.ShadyCSS) {\n                ShadyCSS.prepareTemplate(template, tagName);\n                ShadyCSS.styleElement(this);\n            }\n\n            this.shadowRoot.appendChild(template.content.cloneNode(true));\n        }\n    }//constructor\n\n    // See: https://goo.gl/MDp6j5\n    $upgradeProperty (prop) {\n        if (this.hasOwnProperty(prop)) {\n            let value = this[prop];\n            delete this[prop];\n            this[prop] = value;\n        }\n    }\n\n    // See: https://goo.gl/MUFHD8\n    $defaultAttribute (name, val) {\n        if (!this.hasAttribute(name)) {\n            this.setAttribute(name, val);\n        }\n    }\n\n    // Utility method to generate a unique ID\n    $generateId () {\n        return Math\n            .random()     // 0.7093288430261266\n            .toString(36) // \"0.pjag2nwxb2o\"\n            .substr(2,8); // \"pjag2nwx\"\n    }//$generateId()\n\n    // 'keydown' event listener to prevent page scrolling\n    $preventScroll (evt) {\n        switch (evt.keyCode) {\n            case KEYS.Down:\n            case KEYS.Left:\n            case KEYS.Right:\n            case KEYS.Space:\n            case KEYS.Up:\n                evt.preventDefault();\n                break;\n        }\n    }//$preventScroll()\n\n    $emit (evtName, details) {\n        let evt = new CustomEvent(evtName, {\n            bubbles: true,\n            details: details\n        });\n        this.dispatchEvent(evt);\n    }//$emit\n}//HXElement\n","import { HXElement } from './HXElement';\nimport { KEYS } from '../util';\nimport shadowStyles from './_hx-checkbox.less';\n\nconst tagName = 'hx-checkbox';\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n  <style>${shadowStyles}</style>\n  <div id=\"container\">\n    <hx-icon type=\"checkmark\" id=\"tick\"></hx-icon>\n    <hx-icon type=\"minus\" id=\"minus\"></hx-icon>\n  </div>\n`;\n\nexport class HXCheckboxElement extends HXElement {\n    static get is () {\n        return tagName;\n    }\n\n    static get observedAttributes () {\n        return [\n            'checked',\n            'disabled',\n            'indeterminate',\n        ];\n    }\n\n    constructor () {\n        super(tagName, template);\n    }\n\n    connectedCallback () {\n        this.$defaultAttribute('role', 'checkbox');\n        if (!this.hasAttribute('tabindex') && !this.disabled) {\n            this.setAttribute('tabindex', 0);\n        }\n\n        this.$upgradeProperty('checked');\n        this.$upgradeProperty('disabled');\n        this.$upgradeProperty('indeterminate');\n\n        this.addEventListener('keydown', this.$preventScroll);\n        this.addEventListener('keyup', this._onKeyUp);\n        this.addEventListener('click', this._onClick);\n    }\n\n    disconnectedCallback () {\n        this.removeEventListener('keydown', this.$preventScroll);\n        this.removeEventListener('keyup', this._onKeyUp);\n        this.removeEventListener('click', this._onClick);\n    }\n\n    attributeChangedCallback (name, oldValue, newValue) {\n        const hasValue = newValue !== null;\n        switch (name) {\n            case 'indeterminate':\n                if (hasValue) {\n                    this.setAttribute('aria-checked', 'mixed');\n                }\n                break;\n\n            case 'checked':\n                if (!this.indeterminate) {\n                    this.setAttribute('aria-checked', hasValue);\n                }\n                break;\n\n            case 'disabled':\n                this.setAttribute('aria-disabled', hasValue);\n                if (hasValue) {\n                    this.removeAttribute('tabindex');\n                    this.blur();\n                } else {\n                    this.setAttribute('tabindex', '0');\n                }\n                break;\n        }\n    }//attributeChangedCallback()\n\n    set checked (value) {\n        if (value) {\n            this.setAttribute('checked', '');\n        } else {\n            this.removeAttribute('checked');\n        }\n    }\n\n    get checked () {\n        return this.hasAttribute('checked');\n    }\n\n    set disabled (value) {\n        if (value) {\n            this.setAttribute('disabled', '');\n        } else {\n            this.removeAttribute('disabled');\n        }\n    }\n\n    get disabled () {\n        return this.hasAttribute('disabled');\n    }\n\n    set indeterminate (value) {\n        if (value) {\n            this.setAttribute('indeterminate', '');\n        } else {\n            this.removeAttribute('indeterminate');\n        }\n    }\n\n    get indeterminate () {\n        return this.hasAttribute('indeterminate');\n    }\n\n    _onKeyUp (event) {\n        if (event.altKey) {\n            return;\n        }\n\n        if (event.keyCode === KEYS.Space) {\n            event.preventDefault();\n            this._toggleChecked();\n        }\n    }\n\n    _onClick () {\n        this._toggleChecked();\n    }\n\n    _toggleChecked () {\n        if (this.disabled) {\n            return;\n        }\n        this.indeterminate = false;\n        this.checked = !this.checked;\n\n        let changeEvent = new CustomEvent('change', {\n            detail: {\n                checked: this.checked,\n            },\n            bubbles: true,\n        });\n\n        this.dispatchEvent(changeEvent);\n    }\n}//HXCheckboxElement\n","import { HXElement } from './HXElement';\nimport { KEYS } from '../util';\n\nexport class HXDisclosureElement extends HXElement {\n    static get is () {\n        return 'hx-disclosure';\n    }\n\n    static get observedAttributes () {\n        return [ 'aria-expanded' ];\n    }\n\n    constructor () {\n        super();\n        this._onTargetOpen = this._onTargetOpen.bind(this);\n        this._onTargetClose = this._onTargetClose.bind(this);\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('expanded');\n        this.setAttribute('role', 'button');\n        this.setAttribute('tabindex', 0);\n\n        if (this.target) {\n            this.expanded = this.target.hasAttribute('open');\n            this.target.addEventListener('open', this._onTargetOpen);\n            this.target.addEventListener('close', this._onTargetClose);\n        } else {\n            this.expanded = false;\n        }\n\n        this.addEventListener('click', this._toggle);\n        this.addEventListener('keydown', this.$preventScroll);\n        this.addEventListener('keyup', this._keyUp);\n    }\n\n    disconnectedCallback () {\n        this.removeEventListener('click', this._toggle);\n        this.removeEventListener('keydown', this.$preventScroll);\n        this.removeEventListener('keyup', this._keyUp);\n\n        if (this.target) {\n            this.target.removeEventListener('open', this._onTargetOpen);\n            this.target.removeEventListener('close', this._onTargetClose);\n        }\n    }\n\n    attributeChangedCallback (attr, oldVal, newVal) {\n        if (this.target) {\n            let setTo = (newVal === 'true');\n            if (this.target.open !== setTo) {\n                this.target.open = setTo;\n            }\n        }\n    }\n\n    get expanded () {\n        return this.getAttribute('aria-expanded') === 'true';\n    }\n\n    set expanded (newVal) {\n        this.setAttribute('aria-expanded', !!newVal);\n    }\n\n    get target () {\n        if (!this._target) {\n            let targetId = this.getAttribute('aria-controls');\n            this._target = document.getElementById(targetId);\n        }\n        return this._target;\n    }\n\n    _keyUp (event) {\n        switch (event.keyCode) {\n            case KEYS.Space:\n            case KEYS.Enter:\n                this._toggle();\n                break;\n            default:\n                break;\n        }\n    }\n\n    _toggle () {\n        this.expanded = !this.expanded;\n    }\n\n    _onTargetOpen () {\n        this.expanded = true;\n    }\n\n    _onTargetClose () {\n        this.expanded = false;\n    }\n}//HXDisclosureElement\n","import { HXElement } from './HXElement';\nimport { getPosition } from '../util';\n\nexport class HXMenuElement extends HXElement {\n    static get is () {\n        return 'hx-menu';\n    }\n\n    static get observedAttributes () {\n        return [ 'open' ];\n    }\n\n    constructor () {\n        super();\n        this._onDocumentClick = this._onDocumentClick.bind(this);\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('open');\n        this.$upgradeProperty('position');\n        this.$upgradeProperty('relativeTo');\n        this.$defaultAttribute('position', 'bottom-start');\n        this._initialPosition = this.position;\n        document.addEventListener('click', this._onDocumentClick);\n    }\n\n    disconnectedCallback () {\n        document.removeEventListener('click', this._onDocumentClick);\n    }\n\n    attributeChangedCallback (attr, oldValue, newValue) {\n        this.setAttribute('aria-expanded', newValue !== '');\n    }\n\n    set position (value) {\n        if (value) {\n            this.setAttribute('position', value);\n        } else {\n            this.removeAttribute('position');\n        }\n    }\n\n    get position () {\n        if (this.hasAttribute('position')) {\n            return this.getAttribute('position');\n        }\n        return undefined;\n    }\n\n    set relativeTo (value) {\n        this.setAttribute('relative-to', value);\n    }\n\n    get relativeTo () {\n        return this.getAttribute('relative-to');\n    }\n\n    get relativeElement () {\n        if (this.relativeTo) {\n            return document.getElementById(this.relativeTo);\n        } else {\n            return document.querySelector(`[aria-controls=\"${this.id}\"]`);\n        }\n    }\n\n    set open (value) {\n        if (value) {\n            this.setAttribute('open', '');\n            this._setPosition();\n            this.$emit('open');\n        } else {\n            this.removeAttribute('open');\n            this.$emit('close');\n        }\n    }\n\n    get open () {\n        return this.hasAttribute('open');\n    }\n\n    _setPosition () {\n        var offset = getPosition(this, this.relativeElement, {\n            position: this.position,\n            margin: 2,\n        });\n        this.style.top = offset.y + 'px';\n        this.style.left = offset.x + 'px';\n    }\n\n    _isDescendant (el) {\n        if (el.closest(`hx-menu[id=\"${this.id}\"]`)) {\n            return true;\n        }\n        return false;\n    }\n\n    _isDisclosure (el) {\n        if (el.closest(`hx-disclosure[aria-controls=\"${this.id}\"]`)) {\n            return true;\n        }\n        return false;\n    }\n\n    _onDocumentClick (event) {\n        if (!this._isDescendant(event.target) && !this._isDisclosure(event.target)) {\n            this.open = false;\n        }\n    }\n}//HXMenuElement\n","import { HXElement } from './HXElement';\nimport Icons from '../icons';\n\nexport class HXIconElement extends HXElement {\n    static get is () {\n        return 'hx-icon';\n    }\n\n    static get icons () {\n        return Icons;\n    }\n\n    static get observedAttributes () {\n        return [ 'type' ];\n    }\n\n    constructor (type) {\n        super();\n\n        if (type) {\n            this.type = type;\n        }\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('type');\n        this.$defaultAttribute('aria-hidden', true);\n        this._render();\n    }\n\n    attributeChangedCallback (attr) {\n        this._render();\n    }\n\n    get type () {\n        return this.getAttribute('type');\n    }\n\n    set type (newVal) {\n        this.setAttribute('type', newVal);\n    }\n\n    _render () {\n        // erase previously injected markup\n        this.innerHTML = '';\n\n        if (this.type in Icons) {\n            // create surrogate DIV to add raw SVG markup\n            const tmpDiv = document.createElement('div');\n            tmpDiv.innerHTML = Icons[this.type];\n            // grab SVG from surrogate DIV\n            const svg = tmpDiv.firstElementChild;\n\n            // inject SVG into Light DOM\n            this.appendChild(svg);\n        }\n    }//_render()\n}//HXIconElement\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","import { HXElement } from './HXElement';\nimport { getPositionWithArrow } from '../util';\nimport debounce from 'lodash/debounce';\nimport shadowStyles from './_hx-popover.less';\n\nconst tagName = 'hx-popover';\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n  <style>${shadowStyles}</style>\n  <div id=\"container\" class=\"position-arrow\">\n    <slot name=\"header\"></slot>\n    <slot></slot>\n    <slot name=\"footer\"><slot>\n  </div>\n`;\n\nexport class HXPopoverElement extends HXElement {\n    static get is () {\n        return tagName;\n    }\n\n    static get observedAttributes () {\n        return [ 'open' ];\n    }\n\n    constructor () {\n        super(tagName, template);\n        this._toggle = this._toggle.bind(this);\n        this._setPosition = this._setPosition.bind(this);\n        this._closeOnBackdropClick = this._closeOnBackdropClick.bind(this);\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('open');\n        this.$upgradeProperty('position');\n        this.$defaultAttribute('position', 'bottom-right');\n        this._initialPosition = this.position;\n\n        if (!this.id) {\n            return;\n        }\n\n        this._target = document.querySelector('[data-popover=' + this.id + ']');\n        if (!this._target) {\n            return;\n        }\n\n        this._target.addEventListener('click', this._toggle);\n        window.addEventListener('resize', debounce(this._setPosition, 100));\n        document.addEventListener('click', this._closeOnBackdropClick);\n    }\n\n    disconnectedCallback () {\n        if (!this._target) {\n            return;\n        }\n\n        this._target.removeEventListener('click', this._toggle);\n        window.removeEventListener('resize', debounce(this._setPosition, 100));\n        document.removeEventListener('click', this._closeOnBackdropClick);\n    }\n\n    attributeChangedCallback (attr, oldValue, newValue) {\n        this.setAttribute('aria-hidden', newValue !== '');\n    }\n\n    _toggle () {\n        this.open = !this.open;\n    }\n\n    _setPosition () {\n        let offset = getPositionWithArrow(this, this._target, { position: this.position });\n        this.style.top = `${offset.y}px`;\n        this.style.left = `${offset.x}px`;\n        this.position = offset.position;\n    }\n\n    _closeOnBackdropClick (event) {\n        if (this._isBackground(event) && this.open) {\n            this.open = false;\n        }\n    }\n\n    _isBackground (event) {\n        let inComponent = this.contains(event.target);\n        let inTarget = this._target.contains(event.target);\n        return !inComponent && !inTarget;\n    }\n\n    set open (value) {\n        if (value) {\n            this.setAttribute('open', '');\n            this._setPosition();\n        } else {\n            this.removeAttribute('open');\n            this.position = this._initialPosition;\n        }\n    }\n\n    get open () {\n        return this.hasAttribute('open');\n    }\n\n    set position (value) {\n        if (value) {\n            this.setAttribute('position', value);\n        } else {\n            this.removeAttribute('position');\n        }\n    }\n\n    get position () {\n        return this.getAttribute('position');\n    }\n}\n","import { HXElement } from './HXElement';\n\nexport class HXRevealElement extends HXElement {\n    static get is () {\n        return 'hx-reveal';\n    }\n\n    static get observedAttributes () {\n        return [ 'open' ];\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('open');\n        this.setAttribute('aria-expanded', this.open);\n    }\n\n    attributeChangedCallback (attr, oldVal, newVal) {\n        this.setAttribute('aria-expanded', newVal === '');\n    }\n\n    set open (value) {\n        if (value) {\n            this.setAttribute('open', '');\n        } else {\n            this.removeAttribute('open');\n        }\n    }\n\n    get open () {\n        return this.hasAttribute('open');\n    }\n}//HXRevealElement\n","import { HXElement } from './HXElement';\n\nexport class HXTabcontentElement extends HXElement {\n    static get is () {\n        return 'hx-tabcontent';\n    }\n\n    connectedCallback () {\n        this.$defaultAttribute('role', 'presentation');\n    }\n}//HXTabcontentElement\n","import { HXElement } from './HXElement';\n\nexport class HXTabElement extends HXElement {\n    static get is () {\n        return 'hx-tab';\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('current');\n        this.$defaultAttribute('role', 'tab');\n        this.setAttribute('aria-selected', this.current);\n    }\n\n    static get observedAttributes () {\n        return ['current'];\n    }\n\n    attributeChangedCallback (attr, oldVal, newVal) {\n        this.setAttribute('aria-selected', newVal !== null);\n    }\n\n    get current () {\n        return this.hasAttribute('current');\n    }\n\n    set current (newVal) {\n        if (newVal) {\n            this.setAttribute('current', true);\n        } else {\n            this.removeAttribute('current');\n        }\n    }\n}//HXTabElement\n","import { HXElement } from './HXElement';\n\nexport class HXTablistElement extends HXElement {\n    static get is () {\n        return 'hx-tablist';\n    }\n\n    connectedCallback () {\n        this.$defaultAttribute('role', 'tablist');\n    }\n}//HXTablistElement\n","import { HXElement } from './HXElement';\nimport { HXRevealElement } from './HXRevealElement';\n\nexport class HXTabpanelElement extends HXRevealElement {\n    static get is () {\n        return 'hx-tabpanel';\n    }\n\n    connectedCallback () {\n        super.connectedCallback();\n        this.$defaultAttribute('role', 'tabpanel');\n    }\n\n    // because we are inheriting HXReveal, the only attribute we are watching\n    // is \"open\"\n    attributeChangedCallback (attr, oldVal, newVal) {\n        super.attributeChangedCallback(arguments);\n        this.setAttribute('tabindex', (newVal !== null) ? 0 : -1);\n    }\n}//HXTabpanelElement\n","import { HXElement } from './HXElement';\nimport { KEYS } from '../util';\n\nexport class HXTabsetElement extends HXElement {\n    static get is () {\n        return 'hx-tabset';\n    }\n\n    static get observedAttributes () {\n        return [ 'current-tab' ];\n    }\n\n    constructor () {\n        super();\n        this.$tablist = this.querySelector('hx-tablist');\n        this._onKeyUp = this._onKeyUp.bind(this);\n        this._onTabClick = this._onTabClick.bind(this);\n    }\n\n    connectedCallback () {\n        this.$upgradeProperty('current-tab');\n        this._setupIds();\n        this.currentTab = Number(this.getAttribute('current-tab')) || 0;\n        this.$tablist.addEventListener('keyup', this._onKeyUp);\n        this.$tablist.addEventListener('keydown', this.$preventScroll);\n        this.tabs.forEach( (tab) => {\n            tab.addEventListener('click', this._onTabClick);\n        });\n    }\n\n    disconnectedCallback () {\n        this.$tablist.removeEventListener('keyup', this._onKeyUp);\n        this.$tablist.removeEventListener('keydown', this.$preventScroll);\n        this.tabs.forEach( (tab) => {\n            tab.removeEventListener('click', this._onTabClick);\n        });\n    }\n\n    attributeChangedCallback (attr, oldValue, newVal) {\n        if (!isNaN(newVal)) {\n            this.currentTab = Number(newVal);\n        }\n    }\n\n    get currentTab () {\n        return this._currentTab || 0;\n    }\n\n    set currentTab (idx) {\n        if (isNaN(idx)) {\n            throw new TypeError(`'currentTab' expects an numeric index. Got ${typeof idx} instead.`);\n        }\n\n        if (idx < 0 || idx >= this.tabs.length) {\n            throw new RangeError(`'currentTab' index is out of bounds`);\n        }\n\n        this._currentTab = idx;\n\n        this.tabs.forEach( (tab, tabIdx) => {\n            if (idx === tabIdx) {\n                tab.current = true;\n                tab.setAttribute('tabindex', 0);\n            } else {\n                tab.current = false;\n                tab.setAttribute('tabindex', -1);\n                tab.blur();\n            }\n        });\n\n        this.tabpanels.forEach( (tabpanel, panelIdx) => {\n            tabpanel.open = (idx === panelIdx);\n        });\n    }//SET:currentTab\n\n    get tabs () {\n        return Array.from(this.querySelectorAll('hx-tablist > hx-tab'));\n    }\n\n    get tabpanels () {\n        return Array.from(this.querySelectorAll('hx-tabpanel'));\n    }\n\n    _selectNext () {\n        // if current tab is the last tab\n        if (this.currentTab === (this.tabs.length - 1)) {\n            // select first\n            this.currentTab = 0;\n        } else {\n            // select next\n            this.currentTab += 1;\n        }\n        this.tabs[this.currentTab].focus();\n    }//_selectNext()\n\n    _selectPrevious () {\n        // if current tab is the first tab\n        if (this.currentTab === 0) {\n            // select last\n            this.currentTab = (this.tabs.length - 1);\n        } else {\n            // select previous\n            this.currentTab -= 1;\n        }\n        this.tabs[this.currentTab].focus();\n    }//_selectPrevious()\n\n    // Handle navigating the tabs via arrow keys\n    _onKeyUp (evt) {\n        if (evt.keyCode === KEYS.Right) {\n            this._selectNext();\n        }\n\n        if (evt.keyCode === KEYS.Left) {\n            this._selectPrevious();\n        }\n    }//_onKeyUp()\n\n    _onTabClick (evt) {\n        this.currentTab = this.tabs.indexOf(evt.target);\n    }\n\n    _setupIds () {\n        this.tabs.forEach( (tab, idx) => {\n            let tabpanel = this.tabpanels[idx];\n            // Default tab and panel ID\n            let tabId = `hxTab-${this.$generateId()}`;\n            let tabpanelId = `hxTabPanel-${this.$generateId()}`;\n\n            // Set or keep tab ID\n            if (tab.hasAttribute('id')) {\n                tabId = tab.getAttribute('id');\n            } else {\n                tab.setAttribute('id', tabId);\n            }\n\n            // Set or keep panel ID\n            if (tabpanel.hasAttribute('id')) {\n                tabpanelId = tabpanel.getAttribute('id');\n            } else {\n                tabpanel.setAttribute('id', tabpanelId);\n            }\n\n            tab.setAttribute('aria-controls', tabpanelId);\n            tabpanel.setAttribute('aria-labelledby', tabId);\n        });\n    }//_setupIds\n}//HXTabsetElement\n","import { HXElement } from './HXElement';\nimport { getPositionWithArrow } from '../util';\nimport debounce from 'lodash/debounce';\nimport shadowStyles from './_hx-tooltip.less';\n\nconst tagName = 'hx-tooltip';\nconst template = document.createElement('template');\n\ntemplate.innerHTML = `\n  <style>${shadowStyles}</style>\n  <div id=\"container\" class=\"position-arrow\">\n    <slot></slot>\n  </div>`;\n\nexport class HXTooltipElement extends HXElement {\n    static get is () {\n        return tagName;\n    }\n\n    static get observedAttributes () {\n        return [ 'open' ];\n    }\n\n    constructor () {\n        super(tagName, template);\n        this._show = this._show.bind(this);\n        this._hide = this._hide.bind(this);\n        this._toggle = this._toggle.bind(this);\n        this._setPosition = this._setPosition.bind(this);\n        this._closeOnBackgroundClick = this._closeOnBackgroundClick.bind(this);\n    }\n\n    connectedCallback () {\n        this.$defaultAttribute('position', 'top');\n        this.initialPosition = this.position;\n        this.$upgradeProperty('open');        \n        this.$defaultAttribute('role', 'tooltip');\n\n        if (this.id) {\n            this._target = document.querySelector('[data-tooltip=' + this.id + ']');\n        } else {\n            return;\n        }\n        this._connectHandlers();\n    }\n\n    disconnectedCallback () {\n        if (!this._target) {\n            return;\n        }\n        this._destoryAllHandlers();\n    }\n\n    attributeChangedCallback (attr, oldValue, newValue) {\n        this.setAttribute('aria-hidden', newValue !== '');\n    }\n\n    _hide () {\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n        }\n        this._hideTimer = setTimeout(() => {\n            this.open = false;\n        }, 1600);\n    }\n\n    _show () {\n        if (this._hideTimer) {\n            clearTimeout(this._hideTimer);\n        }\n        this._showTimer = setTimeout(() => {\n            this.open = true;\n        }, 500);\n    }\n\n    _toggle () {\n        this.open = !this.open;\n    }\n\n    _closeOnBackgroundClick (event) {\n        if (this._isBackground(event)) {\n            this.open = false;\n        }\n    }\n\n    _connectHandlers () {\n        window.addEventListener('resize', debounce(this._setPosition,100));\n        if (this.triggerEvent === 'click') {\n            document.addEventListener('click', this._closeOnBackgroundClick);\n            this._target.addEventListener('click', this._toggle);\n        } else {\n            this._target.addEventListener('focus', this._show);\n            this._target.addEventListener('blur', this._hide);\n            this._target.addEventListener('mouseenter', this._show);\n            this._target.addEventListener('mouseleave', this._hide);\n        }\n    }\n\n    _destoryAllHandlers () {\n        window.removeEventListener('resize', debounce(this._setPosition,100));\n        document.removeEventListener('click', this._closeOnBackgroundClick);\n        this._target.removeEventListener('focus', this._show);\n        this._target.removeEventListener('blur', this._hide);\n        this._target.removeEventListener('mouseenter', this._show);\n        this._target.removeEventListener('mouseleave', this._hide);\n        this._target.removeEventListener('click', this._toggle);\n    }\n\n    _setPosition () {\n        var offset = getPositionWithArrow(this, this._target, { 'position':this.position });\n        this.style.top = `${offset.y}px`;\n        this.style.left = `${offset.x}px`;\n        this.position = offset.position;\n    }\n\n    _isBackground (event) {\n        let inComponent = this.contains(event.target);\n        let inTarget = this._target.contains(event.target);\n        return !inComponent && !inTarget ;\n    }\n\n    set position (value) {\n        if (value) {\n            this.setAttribute('position', value);\n        } else {\n            this.removeAttribute('position');\n        }\n    }\n\n    get position () {\n        return this.getAttribute('position');\n    }\n\n    set triggerEvent (value) {\n        if (value) {\n            this.setAttribute('trigger-event', value);\n        } else {\n            this.removeAttribute('trigger-event');\n        }\n    }\n\n    get triggerEvent () {\n        return this.getAttribute('trigger-event');\n    }\n\n    set open (value) {\n        if (value) {\n            this.setAttribute('open', '');\n            this._setPosition();\n        } else {\n            this.removeAttribute('open');\n            this.position = this.initialPosition;\n        }\n    }\n\n    get open () {\n        return this.hasAttribute('open');\n    }\n}//HXTooltipElement\n","import HelixUI from './helix-ui/index';\nimport { version as VERSION } from '../package.json';\n\nHelixUI.VERSION = VERSION;\n\n// add HelixUI to global scope if not already defined\nif (!window.HelixUI) {\n    window.HelixUI = HelixUI;\n}\n\nHelixUI.initialize();\n"],"names":["getCenter","off","ref","left","width","top","height","getTop","config","x","y","margin","getBottom","getLeft","getRight","_getCoords","position","offsetElement","referenceElement","coords","offRect","getBoundingClientRect","refRect","offsetFunctions","window","pageXOffset","pageYOffset","_getOffscreenMetadata","element","elementBox","coord","boundingRect","_getElementBox","viewportBox","innerWidth","innerHeight","offscreen","right","bottom","vertically","horizontally","anywhere","getPosition","cfg","Object","assign","isOffscreen","newCoords","vShiftMap","hShiftMap","_repositionTowardCenter","getPositionWithArrow","_defineElements","attr","elements","$define","KEYS","offset","HXElement","tagName","template","attachShadow","mode","ShadyCSS","prepareTemplate","styleElement","shadowRoot","appendChild","content","cloneNode","define","this","is","prop","hasOwnProperty","value","name","val","hasAttribute","setAttribute","Math","random","toString","substr","evt","keyCode","Down","Left","Right","Space","Up","preventDefault","evtName","details","CustomEvent","dispatchEvent","HTMLElement","document","createElement","innerHTML","HXCheckboxElement","$defaultAttribute","disabled","$upgradeProperty","addEventListener","$preventScroll","_onKeyUp","_onClick","removeEventListener","oldValue","newValue","hasValue","indeterminate","removeAttribute","blur","event","altKey","_toggleChecked","checked","changeEvent","HXDisclosureElement","_onTargetOpen","_this","bind","_onTargetClose","target","expanded","_toggle","_keyUp","oldVal","newVal","setTo","open","Enter","getAttribute","_target","targetId","getElementById","HXMenuElement","_onDocumentClick","_initialPosition","relativeElement","style","el","closest","id","_isDescendant","_isDisclosure","relativeTo","querySelector","_setPosition","$emit","HXIconElement","type","Icons","_render","tmpDiv","svg","firstElementChild","global","freeSelf","self","freeGlobal","Function","root","Date","now","Symbol","objectProto","prototype","nativeObjectToString","symToStringTag","toStringTag","undefined","isOwn","call","tag","unmasked","e","result","nullTag","undefinedTag","getRawTag","objectToString","symbolTag","isObjectLike","baseGetTag","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","isSymbol","isObject","other","valueOf","replace","isBinary","test","slice","FUNC_ERROR_TEXT","nativeMax","max","nativeMin","min","func","wait","options","invokeFunc","time","args","lastArgs","thisArg","lastThis","lastInvokeTime","apply","shouldInvoke","timeSinceLastCall","lastCallTime","maxing","maxWait","timerExpired","trailingEdge","timerId","setTimeout","remainingWait","trailing","debounced","isInvoking","arguments","leading","leadingEdge","TypeError","toNumber","cancel","clearTimeout","flush","HXPopoverElement","_closeOnBackdropClick","debounce","_isBackground","inComponent","contains","inTarget","HXRevealElement","HXTabcontentElement","HXTabElement","current","HXTablistElement","HXTabpanelElement","HXTabsetElement","$tablist","_onTabClick","_setupIds","currentTab","Number","tabs","forEach","tab","_this2","_this3","isNaN","length","focus","_selectNext","_selectPrevious","indexOf","idx","tabpanel","_this4","tabpanels","tabId","$generateId","tabpanelId","_currentTab","RangeError","tabIdx","panelIdx","Array","from","querySelectorAll","HXTooltipElement","_show","_hide","_closeOnBackgroundClick","initialPosition","_connectHandlers","_destoryAllHandlers","_showTimer","_hideTimer","triggerEvent","WebComponents","ready","HelixUI","VERSION","initialize"],"mappings":"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"}